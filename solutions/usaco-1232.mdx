---
id: usaco-1232
source: USACO Silver 2022 Open
title: COW Operations
author: Mythreya Dharani
---
## Explanation
Note that the characters in any queried string can always be moved around in any order.
For example, OC can be permuted by converting to WCC, and then W, and then finally CO.
Therefore, the solution might have to do with the parity of the characters. 

Let us define $C$, $O$, and $W$ as the number of respective characters in a substring that is queried. 
For instance, COWOW would have $C=1$, $O=2$, and $W=2$.

When will it not be possible to convert this substring to a single C? 

We can realize that the parity of $C + W$, $C + O$, or $W + O$ will never change, no matter what operation: 

Removing two adjacent characters does not affect parity.

Turning one character into the other two will remove the occurence of a character and add the occurence of another character, which again, does not change parity.
Thus, one case when it is not possible is when $O + W$ is odd, as we can never remove all O's and W's.
Another case is when $O + C$ or $W + C$ is even, since we can never get one C without any O's or W's.

With this in mind, when it is possible to reduce the string to one $C$? 

Notice that any two adjacent characters can be turned into any single character or removed: If the two characters are the same, simply remove them. 
Otherwise, convert the first character into a character followed by the second character, and remove the pair of second characters. 

Any string can then be reduced to one character, and if $O + W$ is even and $C + W$ is odd, we can always reduce our given substring to one C.

By calculating $C$, $O$, and $W$ in linear time using prefix sums, we can answer each query in constant time.
## Implementation

**Time Complexity:** $\mathcal{O}(N)$

<LanguageSection>
	
<JavaSection>
	
```java
import java.util.*;
import java.io.*;
	
public class COWOperations {
	public static void main(String[] args) throws IOException {
		Kattio io = new Kattio();
		String s = io.next();
		
		// 1-indexed prefix count array for C, O, and W
		int[][] pcount = new int[s.length() + 1][3];  
		
		for (int i = 1; i < s.length() + 1; i++) {
			for (int j = 0; j < 3; j++) {  
				// set each current prefix count to previous count
				pcount[i][j] = pcount[i - 1][j];
			}
			
			// increment count of current character in s
			if (s.charAt(i - 1) == 'C') {
				pcount[i][0]++;
			}
			else if (s.charAt(i - 1) == 'O') {
				pcount[i][1]++;
			}
			else {
				pcount[i][2]++;
			}
		}
		
		int queries = io.nextInt();
		for (int i = 0; i < queries; i++) {  // get each query
			int leftBound = io.nextInt();
			int rightBound = io.nextInt();
			int[] queryCounts = new int[3];
			
			for (int j = 0; j < 3; j++) {  
				// find char count for queried string
				queryCounts[j] = pcount[rightBound][j] - pcount[leftBound - 1][j];
			}
			
			//check if O + W is even and C + O is odd, print answer accordingly
			io.print(((queryCounts[1] + queryCounts[2]) % 2 == 0)
					&& ((queryCounts[0] + queryCounts[1]) % 2 == 1)? "Y": "N");
			
		}
		io.println();
		io.close();
		
		
	}
	//CodeSnip{Kattio}
}
```
	
</JavaSection>

</LanguageSection>

