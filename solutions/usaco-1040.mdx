---
id: usaco-1040
source: USACO Silver 2021 March
title: The Moo Particle
author: Mythreya Dharani
---

## Implementation
Let's assume we have a bidirectional graph where any two particles that can interact are connected. 
We can make the claim that the answer is the number of connected components $c$ in our graph. 
This is true because we can reduce every connected component to one node in the graph by removing all nodes, moving inwards until we reach a single chosen node to keep.

However, there are at most $10^5$ particles, and therefore, we need a way to calculate $c$ in less than $\mathcal{O}(N^2)$. 
We can make a $\mathcal{O}(N \log N)$ algorithm by sorting every particle in ascending order, first by its $x$ spin, and then by its $y$ spin, resulting in a list $p$ of elements $p_1, p_2..p_{N-1}, p_{N}$.
Each element is intially its own connected component. From there, for each adjacent connected component, as long as the minimum y-coordinate in the left component is at most the maximum y-coordinate of the right component, we combine them together.

For some intution on this algorithm's correctness, since the list is already sorted by x-coordinates, by comparing the minimum of the component with smaller y-coordinates and the maximum of the component with greater y-coordinates, we can uniquely determine whether or not they belong to the same connected component.

**Time Complexity:** $\mathcal{O}(N \log N)$

<LanguageSection>

<PySection>

```python
```

</PySection>
	
<JavaSection>
	
```java
import java.util.*;
import java.io.*;
public class TheMooParticle {
	public static void main(String[] args) throws IOException
	{
		Kattio io = new Kattio("moop");
		int n = io.nextInt(); //number of particles
		ArrayList<Integer> x = new ArrayList<>();; //x coordinates
		ArrayList<Integer> y = new ArrayList<>();; //y coordinates
		ArrayList<Integer> components = new ArrayList<>();
		for (int i = 0; i < n; i++)
		{
			x.add(io.nextInt());
			y.add(io.nextInt());
			components.add(i);
		}
		Collections.sort(components, new Comparator<Integer> ()
		{         
			public int compare(Integer p1, Integer p2) //sorts by x, then y
			{
				if (x.get(p1) == x.get(p2))
				{
					return y.get(p1).compareTo(y.get(p2));
				}
				return x.get(p1).compareTo(x.get(p2));
			}
		}
		);
		int[] minLeft = new int[100000]; //stores min y-coordinate for left comp
		int[] maxRight = new int[100000]; //stores max y-coordinate for right comp
		minLeft[0] = y.get(components.get(0));
		for (int i = 1; i < n; i++)
		{
			minLeft[i] = Math.min(minLeft[i - 1], y.get(components.get(i))); //calculates minLeft using prefix mins
		}
		maxRight[n - 1] = y.get(components.get(n - 1));
		for (int i = n - 2; i >= 0; i--)
		{
			maxRight[i] = Math.max(maxRight[i + 1], y.get(components.get(i))); //calculates maxRight using suffix maxs
		}
		int numComponents = 1; //this is our answer
		for (int i = 0; i < n - 1; i++)
		{
			if (minLeft[i] > maxRight[i + 1]) //means they are not in the same component
			{
				numComponents++;
			}
		}
		io.println(numComponents);
		io.close();
		
		
	}
	//CodeSnip{Kattio}
}
```
	
</JavaSection>

</LanguageSection>
